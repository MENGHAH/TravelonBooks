# 常用设计模式

## 1. 单例模式

单例模式是为了保证实例化对象的全局唯一性而提出。在单例模式的设计过程中主要考虑四点：

- 对象不可拷贝（拷贝构造函数==delete）
- 对象不可赋值（复制操作符重载为delete）
- 对象不能被其他程序流程实例化，只能由自己实例化（构造函数私有化）
- 实例化对象或者返回对象时保证线程安全（实例化对象要加互斥锁）

**示例代码：**

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <unistd.h>

class Singleton{
public:
    Singleton(Singleton &other) = delete; //不可拷贝
    void operator=(const Singleton &) = delete; // 不可赋值
    static Singleton *get_singleton_instance(std::string val);
    
    void SomeBusinessLogic(){}
    std::string get_val(){
        std::cout << "start sleep" << std::endl;
        sleep(10);
        std::cout << "end sleep" << std::endl;
        return m_value;
    }
    
private:
    Singleton(std::string val):m_value(val){} // 设置私有函数的原因是是禁止其他程序实例化该对象
    static Singleton* m_singleton;
    static std::mutex m_mutex;
    std::string m_value;
};

Singleton* Singleton::get_singleton_instance(std::string val){
    m_mutex.lock();
    if(m_singleton == nullptr){
        m_singleton = new Singleton(val); // 实例化新的对象要枷加锁
    }
    m_mutex.unlock();
    return m_singleton;
}

Singleton* Singleton::m_singleton = nullptr;
std::mutex Singleton::m_mutex;

void ThreadFoo(){
    // Following code emulates slow initialization.
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    Singleton* singleton = Singleton::get_singleton_instance("FOO");
    std::cout << singleton->get_val() << "\n";
}

void ThreadBar(){
    // Following code emulates slow initialization.
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    Singleton* singleton = Singleton::get_singleton_instance("BAR");
    std::cout << singleton->get_val() << "\n";
}

int main(){
        std::thread thread_1(ThreadFoo);
        std::thread thread_2(ThreadBar);
        thread_1.join();
        thread_2.join();  
    return 0;
}
```

## 2. 工厂模式

工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

### 2.1 简单工厂模式

简单工厂模式的实现比较简单，组件构成并不复杂。该模式的实现主要考虑以下几点：

- 抽象出一个工厂方法，用于new出来具体的产品；
- 抽象出一个产品的公共父类，类内部设置具体产品中必须实现的方法并设置为纯虚函数；
- 继承公共产品父类并实现具体的产品子类；

示例代码：

```c++
#include <iostream>
using namespace std;
enum PRODUCTTYPE {SFJ,XSL,NAS};
// 肥皂抽象产品类
class soapBase
{
	public:
	virtual ~soapBase(){};
	virtual void show() = 0;
};
 // 具体产品类
class SFJSoap:public soapBase
{
	public:
	void show() {cout<<"SFJ Soap!"<<endl;}
};
 
class XSLSoap:public soapBase
{
	public:
	void show() {cout<<"XSL Soap!"<<endl;}
};
 
class NASSoap:public soapBase
{
	public:
	void show() {cout<<"NAS Soap!"<<endl;}
};
 // 工厂类
class Factory
{
	public:
	soapBase * creatSoap(PRODUCTTYPE type)
	{
		switch(type)
		{
			case SFJ: 
				return new SFJSoap();
				break;
			case XSL:
				return new XSLSoap();
				break;
			case NAS:
				return new NASSoap();
				break;
			default:break;
		}
		
	}
};
 // 主函数的实现
int main()
{
	Factory factory;
	soapBase* pSoap1 = factory.creatSoap(SFJ);
	pSoap1->show();
	soapBase* pSoap2 = factory.creatSoap(XSL);
	pSoap2->show();
	soapBase* pSoap3 = factory.creatSoap(NAS);
	pSoap3->show();
	delete pSoap1;
	delete pSoap2;
	delete pSoap3;
	return 0;
}
```

### 2.2 工厂模式

工厂方法模式的应用并不是只是为了封装对象的创建，而是要把对象的创建放到子类中实现：Factory中只是提供了对象创建的接口，其实现将放在Factory的子类ConcreteFactory中进行。
对于真正工厂方法模式的组成主要包括以下四个模块：

- 抽象工厂类（工厂基类）： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。
- 具体工厂类（工厂派生类）：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
- 抽象产品类（产品基类）：它是具体产品继承的父类或者是实现的接口。
- 具体产品类（产品派生类）：具体工厂角色所创建的对象就是此角色的实例。

示例代码：

```c++
#include<iostream>
using namespace std;

// 抽象具体产品类
class SoapBase{
public:
    virtual ~SoapBase(){}
    virtual void show() = 0;
};
// 具体产品类_0
class SFJSoap : public SoapBase{
public:
    void show(){cout << "SFJ Soap" << endl;}
};
// 具体产品类_1
class JJSSoap : public SoapBase{
public:
    void show(){cout << "JJS Soap" << endl;}
};

// 抽象工程类
class FactoryBase{
public:
    virtual SoapBase* creatSoap() = 0;
};
// 具体工厂类_0
class SFJFactory : public FactoryBase{
public:
    SoapBase* creatSoap(){
        return new SFJSoap();
    }
};
// 具体工厂类_1
class JJSFactory : public FactoryBase{
public:
    SoapBase* creatSoap(){
        return new JJSSoap();
    }
};

// 主函数
int main(){
    SFJFactory factory1;
    SoapBase* sfjSoap = factory1.creatSoap();
    sfjSoap->show();

    JJSFactory factory2;
    SoapBase* jjsSoap = factory2.creatSoap();
    jjsSoap->show();
    return 0;
}
```

### 2.3 抽象工厂模式

示例代码：

```c++
#include<iostream>
using namespace std;

enum SOAPTYPE{SFJ,XSL,NAS};
enum TOOTHTYPE{HR,ZH};

// 抽象产品类
class SoapBase
{
    public:
    virtual ~SoapBase(){}
    virtual void show() = 0;
};

// 具体产品类
class SFJSoap : public SoapBase
{
    public:
    void show(){cout << "SFJ Soap" << endl;}
};

// 具体产品类
class NASSoap : public SoapBase
{
    public:
    void show(){cout << "NAS Soap" << endl;}
};

// 抽象牙膏类
class ToothBase
{
	public:
	virtual ~ToothBase(){};
	virtual void show() = 0;
};
 
class HRTooth:public ToothBase
{
	public:
	void show() {cout<<"Hei ren Toothpaste!"<<endl;}
};
 
class ChinaTooth:public ToothBase
{
	public:
	void show() {cout<<"China Toothpaste!"<<endl;}
};

// 抽象工厂类
class FactoryBase
{
    public:
    virtual SoapBase* createSoap() = 0;
    virtual ToothBase* createToothpaste() = 0;
};

// 具体A工厂类，生产SFJ和HR
class FactoryA : public FactoryBase
{
    public:
    SoapBase* createSoap(){
        return new SFJSoap();
    }

    ToothBase* createToothpaste(){
        return new HRTooth();
    }
};

// 具体B工厂类，生产NAS和Chia
class FactoryB : public FactoryBase
{
    public:
    SoapBase* createSoap(){
        return new NASSoap();
    }

    ToothBase* createToothpaste(){
        return new ChinaTooth();
    }
};

int main(){
    FactoryA Factory1;
    FactoryB Factory2;
    SoapBase *pSoap1 = nullptr;
    ToothBase *pToothpaste1 = nullptr;

    pSoap1 = Factory1.createSoap();
    pToothpaste1 = Factory1.createToothpaste();
    pSoap1->show();
    pToothpaste1->show();

    SoapBase *pSoap2 = NULL;
	ToothBase *pToothpaste2 = NULL;
	pSoap2 = Factory2.createSoap();
	pToothpaste2 = Factory2.createToothpaste();
	pSoap2->show();
	pToothpaste2->show();

    delete pSoap1;
	delete pSoap2;
	delete pToothpaste1;
	delete pToothpaste2;
    return 0;
}
```

### 参考文献

- [三种工厂模式的C++实现](https://blog.csdn.net/silangquan/article/details/20492293)

- [C++ 深入浅出工厂模式](https://zhuanlan.zhihu.com/p/83535678)

## 3. 观察者模式

示例代码：

```c++
/*
 * 观察者模式
 * 情景：高数课，ABCD四位同学，A是好学生，去上课，B在寝室睡觉，C在网吧打游戏，D在学校外陪女友逛街
 * 他们约定，如果要点名了，A在QQ群里吼一声，他们立刻赶到教室去。
 * 采用观察者模式实现这个情景的应用。
 */
#include <iostream>
#include <string>
#include <list>

class Observer;

// 订阅主题
class Subject{
public:
    virtual ~Subject() {};
    virtual void registerObsvr(Observer* obsvr) = 0;
    virtual void removeObsvr(Observer* obsvr) = 0;
    virtual void notifyObsvrs(const std::string &msg) = 0;
};

// 观察者的基类
class Observer {
public:
    virtual ~Observer() {};
    virtual void Update(const std::string &msg)= 0;
    virtual std::string getName() = 0;
protected:
    Observer(){}; // 不希望该基类直接实例化。而是通过子类实例化对象;
};


// -------------------具体子类的实现------------------------------
class QQGroup : public Subject {
public:
    QQGroup() { _observers = new std::list<Observer*>(); }
    void registerObsvr(Observer* obsvr);
    void removeObsvr(Observer* obsvr);
    void notifyObsvrs(const std::string &msg);
private:
    std::list<Observer*> *_observers;
};

void QQGroup::registerObsvr(Observer* obsvr) {
    _observers->push_back(obsvr);
}

void QQGroup::removeObsvr(Observer* obsvr) {
    if (_observers->size() > 0)
        _observers->remove(obsvr);
}

void QQGroup::notifyObsvrs( const std::string &msg) {
    std::cout << "群消息：" << msg << std::endl;
    std::list<Observer*>::iterator iter
        = _observers->begin();
    for ( ;iter != _observers->end(); iter++ ) {
    /* 线程安全问题：
     * 做通知的时候，如何知道每个动态创建的对象是否还存活？
     * 是否可以在observer析构时做解注册？但是解注册时如何知道subject是否存活？
     * 根本的解决方案还是智能指针
     */
        (*iter)->Update(msg);
    }
}

// ------------------------------------------------
class RoomMate : public Observer {
public:
    RoomMate(std::string name, std::string now ,std::string action)
    {
        _name = name;
        _action = action;
        _now = now;
    };
    void Update( const std::string &msg);
    std::string getName();
private:
    std::string _name;
    std::string _action;
    std::string _now;
};

std::string RoomMate::getName() {
    return _name;
}

void RoomMate::Update(const std::string &msg) {
    std::cout<< "This is " << _name << std::endl;
    if ( msg == "点名了" )
        std::cout << "Action: " << _action
        << std::endl << std::endl;
    else
        std::cout << "Go on：" << _now
        << std::endl << std::endl ;
}

//测试代码
int main()
{
    RoomMate* B = new RoomMate("B",
        "sleeping",
        "get dressed and run to classroom");
    RoomMate* C = new RoomMate("C",
        "playing games",
        "pay the fee and run to classroom");
    RoomMate* D = new RoomMate("D",
        "shopping with girl friend",
        "go back to school and be worried about girl friend's angry");
    
    // 主题
    QQGroup* qqgroup = new QQGroup();
    qqgroup->registerObsvr(B);
    qqgroup->registerObsvr(C);
    qqgroup->registerObsvr(D);

    qqgroup->notifyObsvrs("目前没点名");
    qqgroup->notifyObsvrs("点名了");

    system("Pause");
    return 0;
}
```

## 4. 建造者模式

**建造者模式(Builder Pattern)**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。   用户只需指定需要建造的类型就可以得到他们，建造过程以及细节不需要知道。

**适用场景**

- 一个对象有非常复杂的内部结构（很多属性）
- 想把复杂对象的创建和使用分离

**优点**

- 封装性好，创建和使用分离
- 扩展性好，建造类之间独立，一定程度可以解偶

**缺点**

- 产生多余的Builder对象
- 产品内部发生变化，建造者都要修改，成本较大



示例代：

```c++
#include <iostream>
using namespace std;

// 要构建的对象
class Graphic {
public:
    Graphic() {}

    // 常变属性的设置接口
    void SetShape(string strShape) {
        m_strShape = strShape;
    }

    void SetColor(string strColor) {
        m_strColor = strColor;
    }

    // 图形的验证方法
    void Show() {
        cout << m_strColor << " " << m_strShape << endl;
    }

private:
    string m_strShape;
    string m_strColor;
};

// 建造者抽象类
class Builder {
public:
    Builder(): m_pGraphic(NULL) {}

    // 创建空白图形
    void CreateGraphic() {
        if (NULL == m_pGraphic) {
            m_pGraphic = new Graphic();
        }
    }

    // 获取描绘完成的图形
    Graphic* GetGraphic() {
        return m_pGraphic;
    }

    // 留给派生类实现的描绘过程
    virtual void DrawShape() = 0;
    virtual void DrawColor() = 0;

protected:
    Graphic* m_pGraphic;
};

// 绿色圆形Builder
class GreenCircleBuilder: public Builder {
public:
    // 根据类的功能实现描绘过程
    void DrawShape() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetShape("Circle");
        }
    }

    void DrawColor() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetColor("Green");
        }
    }
};

// 红色矩形Builder
class RedRectangleBuilder: public Builder {
public:
    // 根据类的功能实现描绘过程
    void DrawShape() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetShape("Rectangle");
        }
    }

    void DrawColor() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetColor("Red");
        }
    }
};

// 蓝色三角形Builder
class BlueTriangleBuilder: public Builder {
public:
    // 根据类的功能实现描绘过程
    void DrawShape() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetShape("Triangle");
        }
    }

    void DrawColor() {
        if (NULL != m_pGraphic) {
            m_pGraphic->SetColor("Blue");
        }
    }
};

// 导演类
class Director {
public:
    Director(): m_pBuilder(NULL) {}

    // 根据需求设置对应的建造者
    void SetBuilder(Builder& pBuilder) {
        m_pBuilder = &pBuilder;
    }

    // 通过建造者获得描绘完成的图形
    Graphic* DrawGraphic() {
        if (NULL == m_pBuilder) {
            return NULL;
        }
        //建造过程为不变的因素
        m_pBuilder->CreateGraphic();
        m_pBuilder->DrawShape();
        m_pBuilder->DrawColor();
        return m_pBuilder->GetGraphic();
    }

private:
    Builder* m_pBuilder;
};

int main()
{
    Director MyDirector;
    // 根据导演的不同需求，分别设置不同的建造者，获得满足需求的图形
    GreenCircleBuilder BuilderGC; // 绿色圆形的建造者
    MyDirector.SetBuilder(BuilderGC);
    Graphic* pGraphicGC = MyDirector.DrawGraphic(); // 导演使用建造者画图
    pGraphicGC->Show();

    RedRectangleBuilder BuilderRB; // 红色矩形的建造者
    MyDirector.SetBuilder(BuilderRB);
    Graphic* pGraphicRB = MyDirector.DrawGraphic(); // 导演使用建造者画图
    pGraphicRB->Show();

    BlueTriangleBuilder BuilderBT; // 蓝色三角的建造者
    MyDirector.SetBuilder(BuilderBT);
    Graphic* pGraphicBT = MyDirector.DrawGraphic(); // 导演使用建造者画图
    pGraphicBT->Show();

    // 资源回收
    if (NULL == pGraphicGC) {
        delete pGraphicGC;
        pGraphicGC = NULL;
    }
    if (NULL == pGraphicRB) {
        delete pGraphicRB;
        pGraphicRB = NULL;
    }
    if (NULL == pGraphicBT) {
        delete pGraphicBT;
        pGraphicBT = NULL;
    }
    return 0;
}
```

