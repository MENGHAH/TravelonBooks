# 参考文章

https://getiot.tech/zh/cplusplus/cpp-stl-array

# 1. STL容器概览

| 数据结构           | 底层实现                                                     | 特点                                           |
| ------------------ | ------------------------------------------------------------ | :--------------------------------------------- |
| vector             | 底层数据结构为数组。                                         | 支持快速随机访问。                             |
| list               | 底层数据结构为双向链表。                                     | 支持快速增删。                                 |
| deque              | 底层数据结构为一个中央控制器和多个缓冲区。                   | 支持首尾（中间不能）快速增删，也支持随机访问。 |
| stack              | 底层一般用 list 和 deque 实现，封闭头部即可，不用 vector 的原因应该是容量大小有限制。 | 扩容耗时。                                     |
| queue              | 底层一般用 list 和 deque 实现，封闭头部即可，不用 vector 的原因应该是容量大小有限制。 | 扩容耗时。                                     |
| priority_queue     | 底层数据结构一般为 vector 为底层容器。                       | 堆 heap 为处理规则来管理底层容器实现。         |
| set                | 底层数据结构为红黑树。                                       | 有序，不重复。                                 |
| multiset           | 底层数据结构为红黑树。                                       | 有序，不重复。                                 |
| map                | 底层数据结构为红黑树。                                       | 有序，不重复。                                 |
| multimap           | 底层数据结构为红黑树。                                       | 有序，不重复。                                 |
| hash_set           | 底层数据结构为 hash 表。                                     | 无序，不重复。                                 |
| unorder_set        | 底层数据结构为 hash 表                                       |                                                |
| hash_multiset      | 底层数据结构为 hash 表。                                     | 无序，不重复。                                 |
| unordered_multiset | 底层数据结构为 hash 表                                       |                                                |
| hash_map           | 底层数据结构为 hash 表。                                     | 无序，不重复。                                 |
| unorder_map        | 底层数据结构为 hash 表                                       |                                                |
| hash_multimap      | 底层数据结构为 hash 表。                                     | 无序，不重复。                                 |
| unordered_multimap | 底层数据结构为 hash 表                                       |                                                |

**unordered_set是在C++11的时候被引入标准库了，而hash_set并没有，所以建议使用unordered_set**

# 2. 涉及底层数据结构介绍

## 2.1 红黑树

红黑树是一种自平衡的二叉搜索树，它可以在进行插入、删除和查找等操作时保持大致的平衡，从而保证了这些操作的时间复杂度为O(log n)。红黑树的每个节点都有一个颜色属性，要么是红色，要么是黑色。红黑树通过以下五个性质来维持其平衡：

**（1）红黑树的性质**

1. **每个节点要么是红色，要么是黑色**。
2. **根节点是黑色的**。
3. **每个叶节点（NIL或空节点）是黑色的**。
4. **如果一个节点是红色的，则它的两个子节点都是黑色的**（从每个叶子到根的所有路径上不能有两个连续的红色节点）。
5. **从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点**（称为黑高度）。

**（2）红黑树的特性**

- **平衡性**：红黑树通过颜色调整和旋转操作来保持树的平衡，从而在插入、删除和查找操作中都能保持较好的性能。
- **有序性**：由于红黑树是二叉搜索树，因此中序遍历（左-根-右）可以得到一个有序序列。
- **稳定性**：红黑树的插入、删除和查找等操作的时间复杂度都是O(log n)，其中n是树中节点的数量。

**（3）红黑树的应用**

- **关联数组**：红黑树可以用于实现关联数组，支持高效的插入、删除和查找操作。
- **内存管理**：某些内存管理算法使用红黑树来跟踪可用和已分配的内存块。
- **文件系统和数据库索引**：红黑树可以用于实现文件系统和数据库中的索引结构，提高数据检索效率。
- **其他**：红黑树还广泛应用于各种需要高效动态查找的场景，如路由表、优先级队列等。

## 2.2 hash表

哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。

比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:

![这里写图片描述](https://img-blog.csdn.net/20170730173706562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRlg2Nzc1ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# 3. 具体STL容器介绍

## 3.1 vector

底层使用数组保存。push_back时若已经满了，则会2*n扩展空间，若实际元素数量低于分配空间的1/4，则会将空间回收为原来的一半。《STL源码剖析》里面没有讲到空间的回收，是之前查找资料时看到。调整空间时，是先申请新的空间，然后将旧空间的内容拷贝过去，然后再释放旧的空间。

只适用于快速查找及只在末尾增删，而不适用于动态增删（可能涉及到元素的移动）。对元素进行增删时，可能导致旧的迭代器失效。

1. list：
     底层是双向链表，支持头尾增删，并且是一个环。

     不适用于查找频繁的情况，但适用于动态增删。

2. deque：
     底层是一个分段的线性表。笼统的说就是使用了一个二维指针，第一维是每段的信息，而第二维就是一个数组了，实际保存的元素就是在这里。

      头尾都支持插入，但是维护麻烦很多。

3. stack
      是一个容器适配器，默认底层使用deque，适配之后只能从头插入和删除。

4. queue
      是一个容器适配器，默认底层使用deque，适配之后只能从尾插入，从头删除。

5. slist
     使用单向链表实现的列表。

6. map、multimap、set
      底层使用红黑树实现，multimap是key值可重复的map。

7. hash_map、hash_set
      底层使用hashtable实现，其中hashtable是采用开链法来防止哈希冲突的。