# 参考文章

[C++ 异常处理](https://www.cnblogs.com/linuxAndMcu/p/10396723.html)

# 什么是异常

程序执行过程中出现的不符合逻辑的表现称为异常。比如线程安全、内存泄漏以及崩溃等。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。

- **try**：**try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 **catch** 块。
- **catch**：在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。
- **throw**：当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。

如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：

```c++
try
{
   // 保护代码
}
catch( ExceptionName e1 )
{
   // catch 块
}
catch( ExceptionName e2 )
{
   // catch 块
}
catch( ExceptionName eN )
{
   // catch 块
}
```

# 捕获异常

**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 **catch** 关键字后的括号内的异常声明决定的。

```c++
try
{
   // 保护代码
}
catch(ExceptionName e) // 指定想要捕捉的异常类型
{
  // 处理 ExceptionName 异常的代码
}
```

上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：

```
try
{
   // 保护代码
}
catch(...) // 能处理任何异常类型
{
  // 处理任何异常的代码
}
```

举例：

```C++
#include <iostream>
using namespace std;

double division(int a, int b)
{
	if (b == 0){
		throw "Division by zero condition!";
	}
	return (a / b);
}

int main()
{
	int x = 50;
	int y = 0;
	double z = 0;

  try {
		z = division(x, y);
		cout << z << endl;
	} atch (const char* msg) {
		cerr << msg << endl;
	}
    
	return 0;
}
```



# 异常处理规则

- throw 抛出的异常类型与 catch 抓取的异常类型要一致；
- throw 抛出的异常类型可以是子类对象，catch 可以是父类对象；
- catch 块的参数推荐采用地址传递而不是值传递，不仅可以提高效率，还可以利用对象的多态性。另外，派生类的异常捕获要放到父类异常扑获的前面，否则，派生类的异常无法被扑获；
- 如果使用 catch 参数中，使用基类捕获派生类对象，一定要使用传递引用的方式，例如 `catch (exception &e)`；
- 被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个；
- 在 try 的语句块内声明的变量在外部是不可以访问的，即使是在 catch 子句内也不可以访问；
- 栈展开会沿着嵌套函数的调用链不断查找，直到找到了已抛出的异常匹配的 catch 子句。如果抛出的异常一直没有函数捕获（catch），则会一直上传到 C++ 运行系统那里，导致整个程序的终止。

# C++ 标准异常

C++ 提供了一系列标准的异常，定义在 `<exception>` 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：

| 异常                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| std::exception        | 该异常是所有标准 C++ 异常的父类。                            |
| std::bad_alloc        | 该异常可以通过 `new` 抛出。                                  |
| std::bad_cast         | 该异常可以通过 `dynamic_cast` 抛出。                         |
| std::bad_exception    | 这在处理 C++ 程序中无法预期的异常时非常有用。                |
| std::bad_typeid       | 该异常可以通过 `typeid` 抛出。                               |
| std::logic_error      | 理论上可以通过读取代码来检测到的异常。                       |
| std::domain_error     | 当使用了一个无效的数学域时，会抛出该异常。                   |
| std::invalid_argument | 当使用了无效的参数时，会抛出该异常。                         |
| std::length_error     | 当创建了太长的 `std::string` 时，会抛出该异常。              |
| std::out_of_range     | 该异常可以通过方法抛出，例如 `std::vector` 和 `std::bitset<>::operator[]()`。 |
| std::runtime_error    | 理论上不可以通过读取代码来检测到的异常。                     |
| std::overflow_error   | 当发生数学上溢时，会抛出该异常。                             |
| std::range_error      | 当尝试存储超出范围的值时，会抛出该异常。                     |
| std::underflow_error  | 当发生数学下溢时，会抛出该异常。                             |

# 其他

**1. 使用异常处理的优点：**

传统错误处理技术，检查到一个错误，只会返回退出码或者终止程序等等，我们只知道有错误，但不能更清楚知道是哪种错误。使用异常，把错误和处理分开来，由库函数抛出异常，由调用者捕获这个异常，调用者就可以知道程序函数库调用出现的错误是什么错误，并去处理，而是否终止程序就把握在调用者手里了。

**2. 使用异常的缺点：**

如果使用异常，光凭查看代码是很难评估程序的控制流：函数返回点可能在你意料之外，这就导致了代码管理和调试的困难。启动异常使得生成的二进制文件体积变大，延长了编译时间，还可能会增加地址空间的压力。

C++ 没有垃圾回收机制，资源需要自己管理。有了异常非常容易导致内存泄漏、死锁等异常安全问题。 这个需要使用 RAII 来处理资源的管理问题。学习成本较高。

C++ 标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱。

**3. 什么时候使用异常？**

建议：除非已有的项目或底层库中使用了异常，要不然尽量不要使用异常，虽然提供了方便，但是开销也大。

**4. 程序所有的异常都可以catch到吗？**

并非如此，只有发生异常，并且又抛出异常的情况才能被 **catch** 到。例如，数组下标访问越界的情况，系统是不会自身抛出异常的，所以我们无论怎么 **catch** 都是无效的；在这种情况，我们需要自定义抛出类型，判断数组下标是否越界，然后再根据自身需要 **throw** 自定义异常对象，这样才可以 **catch** 到异常，并进行进一步处理。