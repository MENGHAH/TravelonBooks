# 1. Java反射

## 1.1 java反射是什么

 java反射就是在运行期间，对于所有的实体类都能够了解该类的属性和方法，并动态地调用任意方法，通俗来说，java反射就是在程序的运行期间，根据类地名称，动态地加载程序并创建对象，还可以任意调动对象中的属性。比如在写代码的时候如果使用了未定义的代码，那么就会在编译的时候出现错误，采用java反射机制就可以有效避免此种错误发生，该机制可以使代码更灵活。

## 1.2 为什么出现java反射

## 1.3 反射的实际作用

- 在编译代码的时候，如果不知道对象或者类属于哪一种类别，程序就无法及时发现对象或类的真实信息，使用java代码可以帮助编程者找到对象的类别。

- 使用java反射还可以使程序的代码访问反射到JVM的内部信息中，包括获取类的方法、类的构造方法、类的成员变量等一系列信息。

- 在不改变代码的前提下，使用java代码能够使用任意的方法、创建任意类的对象，在很大程度上增强了程序的扩展性。

# 2. IOC和AOP

## 2.1 IOC

### 2.1.1 什么是IOC

IOC（inversion of control）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。

例如：现有类 A 依赖于类 B，

- **传统的开发方式** ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来
- **使用 IoC 思想的开发方式** ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。

从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）

**为什么叫控制反转?**

- **控制** ：指的是对象创建（实例化、管理）的权力
- **反转** ：控制权交给外部环境（IoC 容器）

![IoC 图解](.\Java基础知识.assets\frc-365faceb5697f04f31399937c059c162.png)

### 2.1.2 IOC解决了什么问题

IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？

- 对象之间的耦合度或者说依赖程度降低， 当对底层类修改时，依赖链上层的类不需要做修改；
- 资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。

### 2.1.3 IOC和DI（依赖注入）

IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 **将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容器。** 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。

## 2.2 AOP（面向切面编程）

### 2.2.1 什么是AOP

AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补。AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）**从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性**。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。

### 2.2.2 AOP的核心概念

具体来说，AOP中有几个重要的概念：

- **切面（Aspect）**：它们包含了要在特定情况下执行的代码。

- **通知（Advice）**：定义了在何时何地执行切面的代码。比如，在方法执行前、后或者抛出异常时执行。

- **切点（Pointcut）**：定义了哪些核心业务逻辑需要被切面增强。比如，你可能只想在特定的方法或者特定的类上执行切面代码。

# 3. 泛型

在Java中，泛型（Generics）是JDK 5引入的一个新特性，**它允许你在定义类、接口和方法时使用类型参数。这些类型参数在实际使用类、接口或方法时会被具体的类型所替代**，从而提供了编译时的类型安全，并避免了运行时类型转换的潜在异常。

简单来说，泛型就是让你在写代码时能够明确指定容器中要装什么类型的数据，类似于C++中的模板。使用泛型的好处主要有以下几点：

- **类型安全**：泛型允许你在编译时捕获到许多类型不匹配的错误，这减少了在运行时出现类型转换异常的可能性。

- **代码重用**：通过泛型，你可以编写更加通用的代码，这些代码可以适用于多种数据类型，从而提高了代码的重用性。

- **简化代码**：在使用泛型之前，我们通常需要使用Object作为集合类元素的类型，然后在取出元素时再进行强制类型转换。泛型可以让我们在编译时指定集合中元素的类型，从而避免了繁琐的强制类型转换。

举例：

```java
public class Box<T> {  
    private T t;  
  
    public Box(T t) {  
        this.t = t;  
    }  
  
    public T get() {  
        return t;  
    }  
  
    public void set(T t) {  
        this.t = t;  
    }  
}
```

在这个例子中，`Box` 是一个泛型类，它使用一个类型参数 `T`。这个类型参数 `T` 可以用任何类型来替代，比如 `Integer`、`String` 等。当你创建一个 `Box` 对象时，你需要指定具体的类型参数，比如 `Box<Integer>` 或 `Box<String>`。这样，你就可以确保 `Box` 对象中只能存储特定类型的对象，并且在获取和设置对象时不需要进行强制类型转换。

## 3.1 java泛型和C++类模板的区别

- Java的泛型是通过类型擦除来实现的。在编译时，Java编译器会添加必要的类型转换和类型检查代码，但在运行时，所有的泛型信息都会被擦除，也就是说，在Java的泛型集合中，实际上存储的都是Object类型的引用，只是在编译时进行了类型检查。
- C++的模板则不同，它们在编译时就会根据所提供的类型参数来生成特定的类型实例，这些实例在运行时是真实存在的，因此C++的模板提供了完全的静态类型安全。



# Java容器

### 集合（Collection）

1. **List（列表）**：
   - **特点**：有序，可重复。
   - **常用实现**：`ArrayList`（动态数组，随机访问快，增删慢）、`LinkedList`（双向链表，增删快，随机访问慢）、`Vector`（线程安全的动态数组，但现在较少使用）。
2. **Set（集）**：
   - **特点**：无序，不可重复。
   - **常用实现**：`HashSet`（基于哈希表，不保证顺序，查询速度快）、`TreeSet`（基于红黑树，自然排序或自定义比较器排序，有序）。
3. **Queue（队列）**：
   - **特点**：先进先出（FIFO）。
   - **常用实现**：`LinkedList`（也可以作为队列使用）、`PriorityQueue`（优先队列，非严格FIFO，根据优先级出队）。
4. **Deque（双端队列）**：
   - **特点**：双端队列，可以在两端进行插入和删除。
   - **常用实现**：`ArrayDeque`、`LinkedList`（也实现了Deque接口）。
5. **Stack（栈）**：
   - **特点**：后进先出（LIFO），虽然Java集合框架中没有专门的Stack类，但通常使用`Deque`作为栈。

### 映射（Map）

- **特点**：键值对集合，键唯一，值可以重复。

- 常用实现

  ：

  - `HashMap`（基于哈希表，非线程安全，查询速度快），
  - `LinkedHashMap`（保持插入顺序，或者最近最少使用顺序），
  - `TreeMap`（基于红黑树，自然排序或自定义比较器排序，有序），
  - `ConcurrentHashMap`（线程安全，高效并发操作）。
