# 1. QT项目

在Qt项目中，`.pro` 文件是一个项目文件，用于配置和管理Qt应用程序的构建过程。这个文件通常是由Qt的qmake工具使用的，qmake会根据`.pro`文件的内容来生成适用于不同平台和编译器的构建脚本。

```properties
# 注释行，以#开头

# 定义项目名称
TARGET = MyApplication

# 指定项目类型（应用程序、库等）
TEMPLATE = app

# 指定源代码文件
SOURCES += main.cpp \
           myclass.cpp

# 指定头文件
HEADERS += myclass.h

# 指定需要链接的库
LIBS += -lmylibrary

# 指定项目所需的Qt模块（例如Widgets、Network等）
QT += widgets network

# 预处理宏定义
DEFINES += MY_DEFINE

# 编译器选项
QMAKE_CXXFLAGS += -std=c++11

# 指定目标平台（例如Windows、Linux、macOS等）
win32 {
    # Windows特定配置
}

unix {
    # Unix（包括Linux和macOS）特定配置
}

macx {
    # macOS特定配置
}
```

以下是一些常见的.pro文件的配置项：

- TARGET： 指定生成的可执行文件的名称。
- TEMPLATE： 指定项目的类型，例如应用程序（app）、库（lib）等。
- SOURCES： 指定源代码文件的列表。
- HEADERS： 指定头文件的列表。
- LIBS： 指定需要链接的库。
- QT： 指定项目所需的Qt模块。
- DEFINES： 定义预处理宏。
- QMAKE_CXXFLAGS： 指定编译器选项。
- win32/unix/macx： 平台特定的配置，用于针对不同的操作系统设置特定的编译选项。
  

# 2. QT类关系

## 2.1 QT父子关系

**(1) QT的父子关系是什么**



**(2) QT父子关系的使用场景**

- 对象的内存管理：父对象负责管理其所有子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。这种自动释放内存的机制大大简化了对象资源的管理，减少了内存泄漏的风险。
- 信号与槽机制：父子关系对信号与槽机制的使用提供了便利。当一个对象发送信号时，其父对象可以接收并处理该信号。这种机制可以用于在对象之间进行通信和交互。
- 对象的查找和访问：通过父子关系，可以方便地查找和访问对象树中的对象。通过QObject的findChild()和findChildren()等函数，可以在对象树中根据对象名称、类型等条件查找对象，实现对象之间的联动和数据传递。
- 窗口和窗口上的控件之间建立父子关系

**(3) QT类之间父子关系的设定**

```cpp
QObject* parent = new QObject();	   // 创建父对象
QObject* child = new QObject(parent);  // 创建子对象，并指定父对象

Qobject* p = new Qobject( );
Qobject* c1 = new Qobject ();

c1->setParent (p) ;	// 指定父对象
c2->setParent (p);
```

## 2.2 QT树对象模型

Qt中的对象树模型是一种管理QObject及其派生类对象关系的模型。对象树模型用于管理对象的父子关系，即一个QObject对象可以有一个父对象和多个子对象。Qt的对象树模型是一种递归的结构，其中一个对象可以拥有多个子对象，而每个子对象又可以拥有自己的子对象，以此类推。

在对象树模型中，父对象的销毁会导致所有子对象的自动销毁。当一个QObject对象被销毁时，它的所有子对象也会被递归地销毁。这种自动内存管理机制使得在Qt中不需要手动管理对象的生命周期，提高了代码的简洁性和可维护性。

# 3. 信号与槽

## 3.1 默认信号与槽

在Qt中，可以使用默认信号和槽的机制，它允许你不需要手动声明信号和槽，而是使用Qt提供的默认信号和槽来进行连接。默认信号和槽的机制在Qt的部分组件中内置，例如`QPushButton`的点击事件等。

这些内置的信号与槽机制可以通过connect函数实现特定信号和槽函数的关联。

```cpp
#include <QApplication>
#include <QPushButton>
#include <QLineEdit>
#include <QDebug>

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    // QPushButton的默认信号（clicked）与槽的连接
    QPushButton *button = new QPushButton("Click Me");
    QObject::connect(button, &QPushButton::clicked, [=]() {
        qInfo() << "Button Clicked!";
    });

    // QLineEdit的默认信号（textChanged）与槽的连接
    QLineEdit *lineEdit = new QLineEdit();
    QObject::connect(lineEdit, &QLineEdit::textChanged, [=](const QString &text) {
        qInfo() << "Text Changed: " << text;
    });

    // 显示窗口
    button->show();
    lineEdit->show();
    return app.exec();
}
```

## 3.2 自定义信号和槽

自定义信号和槽的使用步骤如下：

**(1) 在类的声明中声明信号：**
在类的声明中使用`signals`关键字声明信号。信号可以带参数，参数类型可以是任何Qt支持的数据类型。

```cpp
class MyObject : public QObject {
    Q_OBJECT
public:
    MyObject() {}

signals:
    void mySignal(int value);
};
```

**(2) 在类的声明中声明槽：**
在类的声明中使用`slots`关键字声明槽。槽函数可以是任何成员函数，用于处理信号触发时的操作。

```cpp
class MyObject : public QObject {
    Q_OBJECT
public:
    MyObject() {}

public slots:
    void mySlot(int value) {
        qDebug() << "Received value: " << value;
    }
};
```

**(3) 在类的实现中使用信号：**
在类的成员函数中使用`emit`关键字来触发信号。当槽函数与信号连接后，信号被触发时，连接的槽函数将被调用.

```cpp
class MyObject : public QObject {
    Q_OBJECT
public:
    MyObject() {}

signals:
    void mySignal(int value);

public slots:
    void triggerSignal() {
        emit mySignal(42);  // 触发信号并传递参数
    }
};
```

**(4) 信号与槽的连接：**
使用`QObject::connect()`函数将信号与槽连接起来。连接成功后，当信号被触发时，与之连接的槽函数将被调用。

```cpp
MyObject *obj = new MyObject();
QObject::connect(obj, &MyObject::mySignal, obj, &MyObject::mySlot);

// 当信号触发时，mySlot函数将被调用
obj->triggerSignal();
```

在上述示例中，MyObject类中定义了一个自定义信号mySignal和一个自定义槽函数mySlot。然后，使用connect()函数将mySignal和mySlot连接起来。当triggerSignal()函数被调用时，mySignal信号被触发，随后连接的槽函数mySlot将被执行，输出"Received value: 42"。

这种自定义信号和槽的机制使得不同对象能够在特定事件发生时进行通信。

## 3.3 QT中的lambda表达式

**(1) 基本语法**

```cpp
[ caputrue ] ( params ) opt -> ret { body; };
```

- capture是捕获列表；

- params是参数表；(选填)

- opt是函数选项；可以填`mutable`,`exception`,`attribute`（选填）
  - mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。
  - exception说明lambda表达式是否抛出异常以及何种异常。
  - attribute用来声明属性。

- ret是返回值类型（拖尾返回类型）。(选填)

- body是函数体。

**(2) 捕获列表**

lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。

- []不捕获任何变量。 

- [&]捕获外部作用域中**所有变量**，**并作为引用在函数体中使用**（按引用捕获）。 

- [=]捕获外部作用域中**所有变量**，**并作为副本在函数体中使用**(按值捕获)。注意值捕获的前提是变量可以拷贝，**且被捕获的量在 lambda 表达式被创建时拷贝，而非调用时才拷贝**。如果希望lambda表达式在调用时能即时访问外部变量，我们应当用引用方式捕获。  

```cpp
// 值捕获
int a = 0;
auto f = [=] { return a; };
a+=1;
cout << f() << endl;       //输出0

// 引用捕获
int a = 0;
auto f = [&a] { return a; };
a+=1;
cout << f() <<endl;       //输出1
```

- [=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。 

- [bar]按值捕获bar变量，同时不捕获其他变量。 

- [this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。**如果已经使用了&或者=，就默认添加此选项**。捕获this的目的是可以在lambda中使用当前类的成员函数和成员变量。





# 4. QMainWindow
## 4.1 QMainWindow

QMainWindow 是Qt框架中的一个核心类，用于创建应用程序的主窗口。它提供了一个标准的应用程序主窗口结构，包括菜单栏、工具栏、状态栏等，并且可以容纳各种自定义的用户界面组件。以下是QMainWindow 的一些主要特性和用法：

主要特性：

- 菜单栏（Menu Bar）： QMenuBar 对象用于创建菜单栏，菜单栏通常包含一个或多个菜单，每个菜单包含若干个菜单项。
- 工具栏（Tool Bar）： QToolBar 对象用于创建工具栏，工具栏通常包含一组快捷操作按钮，用于执行常用的功能。
- 状态栏（Status Bar）： QStatusBar 对象用于创建状态栏，用于显示应用程序的状态信息、提示信息等。
- 中央部件（Central Widget）： 通常是一个自定义的QWidget派生类，作为主窗口的中央区域，用于放置应用程序的主要内容。
- Dock窗口（Dock Widgets）： QDockWidget 对象用于创建可停靠的面板，用户可以拖动和停靠这些面板。
- 文档模型/视图架构（Document-View Architecture）： QMainWindow 支持文档-视图架构，可以通过多文档界面（MDI）或单文档界面（SDI）的方式管理多个文档。
- 布局管理（Layout Management）： QMainWindow 支持布局管理，可以方便地安排各种子组件的位置和大小。

常用方法和函数：

- setMenuBar(QMenuBar *menuBar)： 设置菜单栏。
- addToolBar(QToolBar *toolbar)： 添加工具栏。
- setStatusBar(QStatusBar *statusBar)： 设置状态栏。
- setCentralWidget(QWidget *widget)： 设置中央部件。
- addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget)： 添加Dock窗口。