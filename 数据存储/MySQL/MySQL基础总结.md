# 1. MySQL语句执行的过程

## 1.1 MySQL语句的执行

> 以select语句的执行为例

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

MySQL主要分为两层：**Server层和存储引擎**

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，我们常说的索引数据结构，就是由存储引擎层实现的。

### 1.1.1 连接器

客户端发起连接请求，底层走TCP协议建立长连接（一个MySQL连接默认有效时间是8h，由`wait_timeout` 参数控制）

> MySQL连接也分长连接和短连接

### 1.1.2 缓存查询

如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

但是当对表有更新时，缓存就会失效。所以这种缓存的实用性比较低，在MySQL 8.0版本后就舍弃了。

### 1.1.3 解析 SQL

在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由**解析器**来完成。**解析器**主要完成两件事：**词法分析**和**语法分析**。

### 1.1.4 执行 SQL

经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条`SELECT` 查询语句流程主要可以分为下面这三个阶段：

- 预处理阶段（预处理器）：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
- 优化阶段（优化器）：基于查询成本的考虑， 选择查询成本最小的执行计划；
- 执行阶段（执行器）：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

**(1) 预处理阶段**

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

**(2) 优化阶段**

**优化器负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

**(3) 执行阶段** 

 MySQL 真正开始执行语句是由执行器完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

- 主键索引查询
- 全表扫描
- 索引下推

## 1.2 MySQL数据存储



# 2. B+树

## 2.1 B+树和B树的区别

- B树的每个节点都存储了key和data，而B+树的data存储在叶子节点上。 **B+树非叶子节点仅存储key不存储data，这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。**
- B+树所有叶子节点构成一个**有序链表**，按主键排序来遍历全部记录，能更好支持**范围查找**。由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

- B+树所有的查询都要从根节点查找到叶子节点，**查询性更稳定**；而B树，每个节点都可能查找到数据，需要在叶子节点和内部节点不停的往返移动，所以不稳定。

# 3. 索引及分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

> <font color=red>注意联合索引需要符合最左匹配原则</font>

## 3.1 主键和聚簇/非聚簇索引

[一分钟明白MySQL聚簇索引和非聚簇索引](https://www.cnblogs.com/sy270321/p/12864357.html)

[Mysql-如何正确的使用索引以及索引的原理 ](https://www.cnblogs.com/ManyQian/p/9076247.html)

> - 聚簇索引：将存储的数据和索引放到了一块，找到索引也就找到了数据。
> - 非聚簇索引（二级索引）：将存储的数据存储和索引分开，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。

>  **澄清一个概念**：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

**聚簇索引和非聚簇索引：**聚簇索引和非聚簇索引表示的是一种数据存储的结构。和唯一索引、联合索引等有着概念上的区别。**唯一索引、联合索引**等都叫做辅助索引，也可以称为非聚簇索引，因为通过这些索引只能在叶节点找到主键值和当前索引列的值。如果要想获取当前主键值对应行中的其他数据，还要通过主键进行一次**回表**来获取数据。

**主键索引**是比较特殊的索引，如果通过主键索引进行数据查找，那么在叶节点可以获取当前主键对应行的所有数据， 不再需要回表。

**举例说明：**

```sql
create table student (
    id bigint,
    no varchar(20) ,
    name varchar(20) ,
    address varchar(20) ,
    PRIMARY KEY (`branch_id`) USING BTREE,
    UNIQUE KEY `idx_no` (`no`) USING BTREE
)ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
```

第一种，直接根据主键查询获去所有字段数据，此时主键是聚簇索引，因为主键对应的索引叶子节点存储了id=1的所有字段的值。

```sql
select * from student where id = 1
```

第二种，根据编号查询编号和名称，编号本身是一个唯一索引，但查询的列包含了学生编号和学生名称，当命中编号索引时，该索引的节点的数据存储的是主键ID，需要根据主键ID重新查询一次，所以这种查询下no不是聚簇索引

```sql
select no,name from student where no = 'test'
```

第三种，我们根据编号查询编号（有人会问知道编号了还要查询？要，你可能需要验证该编号在数据库中是否存在），这种查询命中编号索引时，直接返回编号，因为所需要的数据就是该索引，不需要回表查询，这种场景下no是聚簇索引

```sql
select no from student where no = 'test'
```



## 3.2 最左匹配原则

**最左匹配原则：**如果SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，但是**当遇到范围查询(>、<、between、like)就会停止匹配。**如果查询条件中没有使用到最左边的索引，整个联合索引就会**失效**。

例如：如果建立(a,b)顺序的索引，我们的条件只有b=xxx，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2或者b=2 and a=1就可以，因为优化器会自动调整a,b的顺序，并不需要严格按照索引的顺序来；再比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。

![img](https://images2018.cnblogs.com/blog/1036857/201711/1036857-20171126004856453-1491949427.png)

从上图看，当按照联合索引进行数据存储的时候，首先按照最左侧字段顺序进行存储，当最左侧值相同时，再按照第二个字段值的顺序存储。因此， 第一个字段是有序的（1,1,2,2,3,3），但是第二个字段并非有序的。

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 3.4 索引优化方法

常见优化索引的方法：

- 前缀索引优化；
- 覆盖索引优化；
- 主键索引最好是自增的；
- 防止索引失效；

# 4. 事务及隔离级别

https://mp.weixin.qq.com/s/WIqoR0-l7h9SObIzmGDatQ

## **(1) 什么是事务**

数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合（工作逻辑单元）

## **(2) ACID原则**

- 原子性（`Atomicity`）

  最小的工作单元，要么一起成功，要么一起失败

- 一致性(`Consistency`)

  一致性也称作是完整性，就是说事务的执行不能破坏数据库的一致性，一个事务在执行后，数据库必须从一个状态转变为另一个状态

- 隔离性(`Isolation`)

  并发的事务相互隔离，互不干扰

- 持久性(`Durability`)

  持久性是指事务一旦提交，对数据库的状态就应该被永久保存

## (3) ACID是靠什么实现的

- 持久性是通过 redo log （重做日志）来保证的；
- 原子性是通过 undo log（回滚日志） 来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

## **(4) 事务并发操作带来的问题**

### 脏读

**脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。**

> 举个栗子：
>
> 1.张三这个人工资是10000，财务将张三的工资改为了20000（但是事务未提交）；
>
> 2.张三读取自己工资的时候，发现工资变成20000，非常开心；
>
> 3.然后财务发现操作有误，自己改错了，随之回滚了事务，张三的工资又变成了10000，结果小伙那叫个伤心欲绝啊。
>
> **以上**：张三读取到的这个20000就是个脏数据

### 幻读

**是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。**

> 举个栗子：
>
> 假设某公司工资为10000的有10个人
>
> 1.事务1，读取所有工资为10000的员工，会读取到10条记录；
>
> 2.事务2此时向工资表中插入了一条员工记录，工资正好也是10000；
>
> 3.事务1再次读取所有工资为10000的员工，会发现读到了11条记录。
>
> **以上**：就产生了幻觉，如果我们能做到在操作事务未完成数据处理之前，其他的任何事务都不可以添加新数据，则能避免该问题的发生。

### 不可重复读

**是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。**

> 举个栗子：
>
> 1.在事务1中，张三 读取了自己的工资为10000,但是操作还没有完成；
>
> 2.在事务2中，正好财务人员修改了张三的工资为20000,并提交了事务；
>
> 3.在事务1中，张三再次读取自己的工资时，工资变为了20000。
>
> **以上**：此时相当于发生了不可重复读，如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。

**不可重复读的重点是修改** **:**
同样的条件 ,  你读取过的数据 ,  再次读取出来发现值不一样了
**幻读的重点在于新增或者删除**
同样的条件 ,  第 1 次和第 2 次读出来的记录数不一样

为了解决上边所说的几个问题，MySQL对于事务处理有四种隔离级别

## **(5) 四种隔离级别**

- `Read uncommitter`(读未提交) ： 没有解决任何问题

  > 事务中的修改，即使没有提交，对其它事务也是可见的。

- `Read Committer`(读提交) ：解决了脏读问题

  > 个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

- `Repeatable Read`(<font color=red>**可重复读**，**默认隔离级别**</font>)： 解决了不可重复读和脏读问题（ps:在Innodb情况下，也不可能发生幻读问题）

  > 保证在同一个事务中多次读取同样数据的结果是一样的。

- `Serializable`(串行化) ：脏读、幻读、不可重复读三个问题全部解决了

  > 强制事务串行执行。

# InnoDB锁机制

https://juejin.cn/post/6844903778026520584

锁是用于管理不同事务对共享资源的并发访问

## 行锁和表锁

行锁是针对单独行加锁，表锁是针对整个表加锁。行锁的粒度小于表锁。

**表锁和行锁的区别：**

在加锁效率、锁定粒度以及冲突概率上，表锁大于行锁。在并发性能上，表锁远低于行锁。表锁是锁定了整个表，在加锁期间，无论读写，这个表的数据都是锁定的，相反行锁只是锁定了这个表中的一条数据，其他数据仍然可以操作，这很好提高了数据库的并发性能。

## InnoDB锁类型

- 共享锁 Shared Locks  （简称 S 锁，属于行锁）

- 排他锁 Exclusive Locks（简称 X 锁，属于行锁）

- 意向共享锁 Intention Shared Locks （简称 IS 锁，属于表锁）

- 意向排他锁 Intention Exclusive Locks （简称 IX 锁，属于表锁）

- 自增锁 AUTO-INC Locks

# MySQL日志

[简单聊聊MySQL中的六种日志](https://juejin.cn/post/7077577452372885535)

MySQL中存在着以下几种日志：重写日志（redo log）、回滚日志（undo log）、二进制日志（bin log）、错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log）。

## <font color=red>**(1) redo log**</font>

redo log是一种基于磁盘的数据结构，用来在MySQL宕机情况下将不完整的事务执行数据纠正，redo log记录事务执行后的状态。

当事务开始后，redo log就开始产生，并且随着事务的执行不断写入redo log file中。redo log file中记录了xxx页做了xx修改的信息，我们都知道数据库的更新操作会在内存中先执行，最后刷入磁盘。redo log就是为了**恢复更新了内存但是由于宕机等原因没有刷入磁盘**中的那部分数据。

## <font color=red>**(2) undo log**</font>

undo log主要用来回滚到某一个版本，是一种逻辑日志。**undo log记录的是修改之前的数据**，比如：当delete一条记录时，undo log中会记录一条对应的insert记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过undo log中的记录内容并以此进行回滚。undo log还可以提供多版本并发控制下的读取（**MVCC**）。

## 其他log

**(3) bin log**

MySQL的bin log日志是用来记录MySQL中增删改时的记录日志。简单来讲，就是当你的一条sql操作对数据库中的内容进行了更新，就会增加一条bin log日志。查询操作不会记录到bin log中。bin log最大的用处就是进行**主从复制，以及数据库的恢复。**

**(4) error log**

error log主要记录MySQL在启动、关闭或者运行过程中的错误信息，在MySQL的配置文件my.cnf中，可以通过log-error=/var/log/mysqld.log 执行mysql错误日志的位置。

**(5) slow query log**

慢查询日志用来记录执行时间超过指定阈值的SQL语句，慢查询日志往往用于优化生产环境的SQL语句。可以通过以下语句查看慢查询日志是否开启以及日志的位置：

```sql
 show variables like "%slow_query%";
```

慢查询日志的常用配置参数如下：

```sql
slow_query_log=1  #是否开启慢查询日志，0关闭，1开启
slow_query_log_file=/usr/local/mysql/mysql-8.0.20/data/slow-log.log  #慢查询日志地址（5.6及以上版本）
long_query_time=1 #慢查询日志阈值，指超过阈值时间的SQL会被记录
log_queries_not_using_indexes  #表示未走索引的SQL也会被记录
```

分析慢查询日志一般会用专门的日志分析工具。找出慢SQL后可以通过explain关键字进行SQL分析，找出慢的原因。

**(6) general log**

general log 记录了客户端连接信息以及执行的SQL语句信息，通过MySQL的命令

```sql
show variables like '%general_log%';
```

可以查看general log是否开启以及日志的位置。

general log 可通过配置文件启动，配置参数如下：

```sql
general_log = on
general_log_file = /usr/local/mysql/mysql-8.0.20/data/hecs-78422.log
```

普通查询日志会记录增删改查的信息，因此一般是关闭的。

# MVCC机制

[五分钟搞清楚 MVCC 机制](https://juejin.cn/post/6844903778026536968)

<font color=red>**MVCC基于可重复读的隔离级别实现**</font>

## (1) 概念

MVCC即多版本并发控制。MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到**不加锁**，非阻塞并发读。

## (2) 当前读和快照读

**(1) 当前读**

像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？**就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁**

**(2) 快照读**

像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

## (3) MVCC的实现原理

如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，**在某个瞬间看到的是数据库的一个快照**，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。

当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。**这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。**对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。

<font color=red>MVCC 并发控制下的读事务一般使用**时间戳或者事务 ID**去标记当前读的数据库的版本，读取当前版本的数据。**读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。读、写事务相互隔离，不需要加锁。**</font>

## (4) MVCC逻辑流程

在`MySQL`中建表时，每个表都会有三列隐藏记录，其中和`MVCC`有关系的有两列

- 数据行的版本号 （`DB_TRX_ID`）
- 删除版本号 (`DB_ROLL_PT`)

| `id` | `test_id` | DB_TRX_ID（数据行版本号） | DB_ROLL_PT（删除版本号） |
| ---- | --------- | ------------------------- | ------------------------ |
|      |           |                           |                          |

**(1) 插入**

在插入数据的时候，首先获取全局事务ID，再执行后续操作逻辑。假设系统的全局事务ID从1开始，以下SQL语句执行分析参考注释信息：

```
复制代码begin;-- 获取到全局事务ID
insert into `test_zq` (`id`, `test_id`) values('5','68');
insert into `test_zq` (`id`, `test_id`) values('6','78');
commit;-- 提交事务
```

当执行完以上SQL语句之后，表格中的内容会变成：

| id   | test_id | DB_TRX_ID（数据行版本号） | DB_ROLL_PT（删除版本号） |
| ---- | ------- | ------------------------- | ------------------------ |
| 5    | 68      | 1                         | NULL                     |
| 6    | 78      | 1                         | NULL                     |

可以看到，插入的过程中会把全局事务ID记录到列 DB_TRX_ID 中去

**(2) 删除**

对上述表格做删除逻辑，执行以下SQL语句（假设获取到的事务逻辑ID为 3）

```
复制代码begin；--获得全局事务ID = 3
delete test_zq where id = 6;
commit;
```

执行完上述SQL之后数据并没有被真正删除，而是对删除版本号做改变，如下所示：

| id   | test_id | DB_TRX_ID（数据行版本号） | DB_ROLL_PT（删除版本号） |
| ---- | ------- | ------------------------- | ------------------------ |
| 5    | 68      | 1                         | NULL                     |
| 6    | 78      | 1                         | 3                        |

**(3)修改**

修改逻辑和删除逻辑有点相似，修改数据的时候 会先复制一条当前记录行数据，同事标记这条数据的数据行版本号为当前是事务版本号，最后把原来的数据行的删除版本号标记为当前是事务。

执行以下SQL语句：

```
复制代码begin;-- 获取全局系统事务ID 假设为 10
update test_zq set test_id = 22 where id = 5;
commit;
```

执行后表格实际数据应该是：

| id   | test_id | DB_TRX_ID（数据行版本号） | DB_ROLL_PT（删除版本号） |
| ---- | ------- | ------------------------- | ------------------------ |
| 5    | 68      | 1                         | 10                       |
| 6    | 78      | 1                         | 3                        |
| 5    | 22      | 10                        | NULL                     |

**(4)查询**

数据查询规则如下：

- 查找**数据行版本号早于当前事务版本号**的数据行记录

  也就是说，数据行的版本号要小于或等于当前是事务的系统版本号，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据

- 查找**删除版本号**要么为NULL，要么**大于当前事务版本号**的记录

  这样确保查询出来的数据行记录在事务开启之前没有被删除

根据上述规则，我们继续以上张表格为例，对此做查询操作

```
复制代码begin;-- 假设拿到的系统事务ID为 12
select * from test_zq;
commit;
```

执行结果应该是：

| id   | test_id | DB_TRX_ID（数据行版本号） | DB_ROLL_PT（删除版本号） |
| ---- | ------- | ------------------------- | ------------------------ |
| 6    | 22      | 10                        | NULL                     |

# 主从复制原理

- [主从复制原理](https://dongzl.github.io/2020/03/15/12-MySQL-Master-Slave-Replication/index.html)

## (1) 什么是主从复制

MySQL 主从复制是指数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

## (2) 为什么需要主从复制

- 提高数据库读写性能，提升系统吞吐量

在业务复杂的系统中，如果有一条 SQL 语句的执行需要锁表，导致 MySQL 暂时不能提供读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。

- 做数据库热备
- 架构扩展需要

业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O 访问的频率，提升整个数据库性能。

## (3) MySQL 的复制原理

**原理**：

- master 服务器将数据的改变记录二进制 binlog 日志，当 master 上的数据发生改变时，则将其改变写入二进制日志中；
- slave 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变，则开始一个 I/OThread 请求 master 二进制事件；
- 同时主节点为每个 I/O 线程启动一个 dump 线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动 SQL 线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后 I/OThread 和 SQLThread 将进入睡眠状态，等待下一次被唤醒。

**也就是**：

- 从库会生成**两个线程**,一个 I/O 线程,一个 SQL 线程；
- I/O 线程会去请求主库的 binlog，并将得到的 binlog 写到本地的 relay-log（中继日志）文件中；主库会生成一个 log dump 线程,用来给从库 I/O 线程传 binlog；
- SQL 线程，会读取 relay log 文件中的日志，并解析成sql语句逐一执行。

**注意**：

- master 将操作语句记录到 binlog 日志中，然后授予 slave 远程连接的权限（master 一定要开启 binlog 二进制日志功能；通常为了数据安全考虑，slave 也开启binlog功能）；
- slave 开启两个线程：IO 线程和 SQL 线程。其中：IO 线程负责读取 master 的 binlog 内容到中继日志 relay log 里；SQL 线程负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里，这样就能保证 slave 数据和 master 数据保持一致了；
- MySQL 复制至少需要两个 MySQL 的服务，当然 MySQL 服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务；
- MySQL复制最好确保 master 和 slave 服务器上的 MySQL 版本相同（如果不能满足版本一致，那么要保证 master 主节点的版本低于 slave 从节点的版本）；
- master 和 slave 两节点间时间需同步。

![img](https://cdn.jsdelivr.net/gh/dongzl/dongzl.github.io@hexo/source/images/2020/12-MySQL-Master-Slave-Replication/MySQL-Master-Slave-Replication-01.jpeg)

**具体步骤**：

- 从库通过手工执行 change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）start slave；
- 从库的 IO 线程和主库的 dump 线程建立连接；
- 从库根据 change master to 语句提供的 file 名和 position 号，IO 线程向主库发起 binlog 的请求；
- 主库 dump 线程根据从库的请求，将本地 binlog 以 events 的方式发给从库IO 线程；
- 从库 IO 线程接收 binlog events，并存放到本地 relay-log 中，传送过来的信息，会记录到 `master.info` 中；
- 从库 SQL 线程应用 relay-log，并且把应用过的记录到 `relay-log.info` 中，默认情况下，已经应用过的 relay 会自动被清理 purge。

## (4) MySQL 主从复制延时分析

MySQL 的主从复制都是单线程的操作，主库对所有 DDL 和 DML 产生的日志写进 binlog，由于 binlog 是顺序写，所以效率很高，slave 的 SQL thread 线程将主库的 DDL 和 DML 操作事件在 slave 中重放。DML 和 DDL 的 IO 操作是随机的，不是顺序，所以成本要高很多，另一方面，由于 SQL thread 也是单线程的，当主库的并发较高时，产生的 DML 数量超过 slave 的 SQL thread 所能处理的速度，或者当 slave 中有大型 query 语句产生了锁等待，那么延时就产生了。

**解决方案**：

- 业务的持久层实现采用分库架构，mysql 服务可以水平扩展，分散压力；
- 单个库读写分离，一主多从，主写从读，分散压力；这样从库压力可能会比主库高，保护主库。
- 服务的基础架构在业务系统和mysql之间加入memcache或者redis 的cache层，降低mysql读压力。
- 不同业务的mysql物理上放在不同的机器，分散压力。
- 使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。
- 使用更加强劲的硬件设备。

## (5) MySQL 主从复制的形式

- 一主一从
- 主主复制
- 一主多从
- 多主一从
- 级联复制

# 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于:

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

# 分表、分库、分片和分区

[分库分表之终极设计方案](https://zhuanlan.zhihu.com/p/66842274)

[总结下Mysql分表分库的策略及应用](https://www.cnblogs.com/phpper/p/6937896.html)

## (1) MySQL分库分表

MySQL分库分表是一种数据库分割和划分数据表的技术。它将原本存储在单个数据库中的数据分散到多个数据库中，将原本单个表中的数据分散到多个数据表中。通过这种方式，可以提高数据库的查询性能和扩展性，同时降低数据库的负载。

## (2) 为什么需要分库分表

当数据库中存储的数据量庞大，且并发访问量高时，单个数据库可能无法满足快速查询和高并发的需求。此时，通过分库分表可以将数据分散存储，提高查询效率和负载均衡，进而提高系统的性能。

## (3) 分库分表的实现方法和步骤

**3.1 水平分库**

水平分库是指将原本存储在一个数据库中的数据分散到多个独立的数据库中。实现水平分库的方法一般有两种：

- 按数据范围分库：根据数据的某个字段的取值范围，将数据分散到不同的数据库中。比如，根据用户ID的奇偶性将数据分散到两个数据库中。
- 按哈希算法分库：根据数据的哈希值，将数据均匀地分散到多个数据库中。这种分库方式可以保证数据在各个库中的分布相对均衡。

**3.2 垂直分库**

垂直分库是指将原本存储在一个数据库中的数据根据表的关系分散到多个数据库中。实现垂直分库的方法一般有两种：

- 按功能分库：将不同功能的数据分散到不同的数据库中。比如，将用户信息和订单信息分别存储在不同的数据库中。
- 按表的关系分库：将数据库中的表按照其关系划分到不同的数据库中。比如，将用户表和订单表分别存储在不同的数据库中。

**3.3 水平分表**

水平分表是指将原本存在单个数据表中的数据分散存储到多个数据表中。实现水平分表的方法一般有两种：

- 按数据范围分表：根据数据的某个字段的取值范围，将数据分散到不同的数据表中。比如，根据用户ID的奇偶性将数据分散到两个数据表中。
- 按哈希算法分表：根据数据的哈希值，将数据均匀地分散到多个数据表中。这种分表方式可以保证数据在各个表中的分布相对均匀。

**3.4 垂直分表**

垂直分表是指将原本存在单个数据库表中的字段根据字段的不同特性分散到多个数据表中。实现垂直分表的方法一般有两种：

- 按类型分表：将不同类型的字段分散到不同的数据表中。比如，将用户的基本信息和扩展信息分别存储在不同的数据表中。
- 按字段关系分表：将字段之间有关联的数据分散存储到不同的数据表中。比如，将用户的基本信息和订单信息分别存储在不同的数据表中。

## (4) 何时需要分库分表



## (5) 常见分库分表中间件

常见的分库分表中间件包括MyCAT、Atlas、ShardingSphere等。这些中间件可以提供高性能的分库分表功能，并且具有一些自动化的管理工具和特性。



# MySQL 常用语句

## 常用操作数据库命令

```sql
show databases; 查看所有的数据库
create database test; 创建一个叫test的数据库
drop database test;删除一个叫test的数据库
use test;选中库 ,在建表之前必须要选择数据库
show tables; 在选中的数据库之中查看所有的表

create table 表名 (字段1 类型, 字段2 类型);
例如：CREATE TABLE tbl(
        id INT NOT NULL AUTO_INCREMENT, 
        title VARCHAR(100) NOT NULL, 
        author VARCHAR(40) NOT NULL, 
        date DATE, 
        PRIMARY KEY ( id ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 
        
desc 表名;查看所在的表的字段
drop table 表名; 删除表
show create databases 库名;查看创建库的详细信息
show create table 表名; 查看创建表的详细信息
```

## 修改表命令

```sql
修改字段类型： alter table 表名 modify 字段 字段类型;
添加新的字段： alter table 表名 add 字段 字段类型;
添加字段并指定位置：  alter table 表名 add 字段 字段类型 after 字段;
删除表字段：  alter table 表名 drop 字段名;
修改指定的字段：  alter table 表名 change 原字段名字 新的字段名字 字段类型;
```

## 对数据操作

### 增删改查

#### **插入**&删除&更新

**插入**

```sql
insert into 表名 values(值1，值2，...)(很少用)

insert into 表名(字段1，字段2...) values(值1，值2，....);（较常用）
例如：INSERT INTO tbl 
    (title, author, date)
    VALUES
    ("学习 PHP", "菜鸟", NOW());
    
insert into 表名(字段1，字段2...) values(值1，值2，....)，(值1，值2，....)，(值1，值2，....);
```

**删除**

```sql
(delete) delete from 表名 where 条件 注意：where 条件必须加，否则数据会被全部删除
```

**更新**

```sql
update 表名 set字段1 = 值1, 字段2 = 值2 where 条件
```

#### **查询**

**1)普通查询**

```sql
查询表中的所有数据   select * from 表名
指定数据查询        select 字段 from 表名 
根据条件查询出来的数据  select 字段 from 表名 where 条件 (最常用的)
 
​ where 条件后面跟的条件
​ 关系：>,<,>=,<=,!= (注意最左匹配原则)
​ 逻辑：or, and
​ 区间：id between 4 and 6 ;闭区间，包含边界

查询结果排序：       select 字段 from 表 order by 字段 排序关键词(desc|asc)
查询结果多字段排序：  select 字段 from 表 order by 字段1  desc|asc, ..., 字段n desc|asc;
限制查询结果展示量： 	select * from 表名  limit 偏移量,数量; // 偏移量默认为0
```

**2)常用的统计函数 sum，avg，count，max,min**

```sql
只分组:   select * from 表 group by 字段
例子:     select count(sex) as re,sex from star group by sex having re > 3;
分组统计:  select count(sex) from star group by sex;
```

#### **分组查询-group by**

```sql
SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
```

```sql
mysql> SELECT * FROM employee_tbl;
+----+--------+---------------------+--------+
| id | name   | date                | singin |
+----+--------+---------------------+--------+
|  1 | 小明 | 2016-04-22 15:25:33 |      1 |
|  2 | 小王 | 2016-04-20 15:25:47 |      3 |
|  3 | 小丽 | 2016-04-19 15:26:02 |      2 |
|  4 | 小王 | 2016-04-07 15:26:14 |      4 |
|  5 | 小明 | 2016-04-11 15:26:40 |      4 |
|  6 | 小明 | 2016-04-04 15:26:54 |      2 |
+----+--------+---------------------+--------+
6 rows in set (0.00 sec)

mysql> SELECT name, COUNT(*) FROM employee_tbl GROUP BY name;
+--------+----------+
| name   | COUNT(*) |
+--------+----------+
| 小丽 |        1 |
| 小明 |        3 |
| 小王 |        2 |
+--------+----------+
3 rows in set (0.01 sec)
```

#### **组合查询-union**

MySQL `UNION` 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。

```sql
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];
```

使用举例：从下述两张表中统计出所有出现的country
```sql
SELECT * FROM Websites;
+----+--------------+---------------------------+-------+---------+
| id | name         | url                       | alexa | country |
+----+--------------+---------------------------+-------+---------+
| 1  | Google       | https://www.google.cm/    | 1     | USA     |
| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |
| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |
| 4  | 微博          | http://weibo.com/         | 20    | CN      |
| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |
| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |
+----+---------------+---------------------------+-------+---------+

 SELECT * FROM apps;
+----+------------+-------------------------+---------+
| id | app_name   | url                     | country |
+----+------------+-------------------------+---------+
|  1 | QQ APP     | http://im.qq.com/       | CN      |
|  2 | 微博 APP | http://weibo.com/       | CN      |
|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |
+----+------------+-------------------------+---------+
```
查询语句及结果
```sql
# 查询条件及结果1：
SELECT country FROM Websites
UNION
SELECT country FROM apps
ORDER BY country;

# 结果：
+----+
| country | 
+----+-
|  CN  | 
|  IND | 
|  USA | 
+----+

# 查询条件及结果2：
SELECT country FROM Websites
UNION ALL
SELECT country FROM apps
ORDER BY country;

# 结果：
+----+
| country | 
+----+-
|  CN  | 
|  CN  | 
|  CN  | 
|  CN  | 
|  CN  | 
|  IND | 
|  USA | 
|  USA | 
|  USA | 
+----+
```

#### 表联合查询-join

在RUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl。两张数据表数据如下：

```sql
mysql> use RUNOOB;
Database changed
mysql> SELECT * FROM tcount_tbl;
+---------------+--------------+
| runoob_author | runoob_count |
+---------------+--------------+
| 菜鸟教程  | 10           |
| RUNOOB.COM    | 20           |
| Google        | 22           |
+---------------+--------------+
3 rows in set (0.01 sec)
 
mysql> SELECT * from runoob_tbl;
+-----------+---------------+---------------+-----------------+
| runoob_id | runoob_title  | runoob_author | submission_date |
+-----------+---------------+---------------+-----------------+
| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |
| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |
| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |
| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |
| 5         | 学习 C      | FK            | 2017-04-05      |
+-----------+---------------+---------------+-----------------+
5 rows in set (0.01 sec)
```

4.1 INNER JOIN（内连接,或等值连接）
![img](E:\03_常用文件\TravelonBooks\数据存储\MySQL\MySQL基础总结.assets\1196462-20191225004446903-1068184925.gif)

```sql
mysql> SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程    | 10             |
| 2           | 菜鸟教程    | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
+-------------+-----------------+----------------+
4 rows in set (0.00 sec)
```

4.2 LEFT JOIN（左连接）
![img](E:\03_常用文件\TravelonBooks\数据存储\MySQL\MySQL基础总结.assets\1196462-20191225004459480-1473356142.gif)

```sql
mysql> SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程    | 10             |
| 2           | 菜鸟教程    | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
| 5           | FK              | NULL           |
+-------------+-----------------+----------------+
5 rows in set (0.01 sec)
```

4.3 RIGHT JOIN（右连接）
![img](E:\03_常用文件\TravelonBooks\数据存储\MySQL\MySQL基础总结.assets\1196462-20191225004509099-1149596663.gif)

```sql
mysql> SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
+-------------+-----------------+----------------+
| a.runoob_id | a.runoob_author | b.runoob_count |
+-------------+-----------------+----------------+
| 1           | 菜鸟教程    | 10             |
| 2           | 菜鸟教程    | 10             |
| 3           | RUNOOB.COM      | 20             |
| 4           | RUNOOB.COM      | 20             |
| NULL        | NULL            | 22             |
+-------------+-----------------+----------------+
5 rows in set (0.01 sec)
```

## 事务

## 索引

### 普通索引

**创建索引**

这是最基本的索引，它没有任何限制。它有以下几种创建方式：

```scss
CREATE INDEX indexName ON mytable(username(length)); 
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

**修改表结构(添加索引)**

```sql
ALTER table tableName ADD INDEX indexName(columnName)
```

**创建表的时候直接指定**

```sql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

**删除索引的语法**

```delphi
DROP INDEX [indexName] ON mytable; 
```

### 唯一索引

它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：

**创建索引**

```scss
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

**修改表结构**

```sql
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

**创建表的时候直接指定**

```sql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))  
 
);  
```

### 使用ALTER 命令添加和删除索引

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。
- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

以下实例为在表中添加索引。

```sql
mysql> ALTER TABLE testalter_tbl ADD INDEX (c);
```

你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:

```sql
mysql> ALTER TABLE testalter_tbl DROP INDEX c;
```
