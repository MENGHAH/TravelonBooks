# 1. 常用的SQL优化策略

## 1.1 几种重要策略

可以从这几个维度考虑日常SQL语句的优化：

- 加索引（需要在经常使用的数据段上添加）
- 避免返回不必要的数据
- 适当分批量进行（插入为了缩短IO、也可以分批进行）
- 优化sql结构
- 分库分表
- 读写分离

### 1.1.1 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。读写分离能提高性能的原因在于:

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

### 1.1.2 分库分表

**(1) 何时需要分库分表**

**1) 性能瓶颈**

- **高并发读写**：当数据库面临极高的并发读写请求，单个数据库实例难以处理如此大量的请求，导致响应时间延长，用户体验下降。
- **资源饱和**：CPU、内存或I/O资源经常达到极限，增加硬件资源的成本效益比不高或已达到硬件上限。

**2) 数据量增长**

- **单表数据量巨大**：单表数据量达到亿级别甚至更高，查询效率显著下降，特别是涉及到全表扫描或大范围索引扫描的操作。
- **存储空间限制**：单个数据库实例的存储空间接近或达到最大容量，且数据仍持续增长。

**3) 扩展性需求**

- **业务快速扩展**：业务发展迅速，未来数据量和访问量预计会有指数级增长，需要提前布局可扩展的数据库架构。
- **弹性伸缩**：希望根据业务负载动态调整数据库资源，实现成本效益最大化。

**4) 数据隔离与安全性**

- **业务隔离**：不同业务模块或部门之间需要数据隔离，以提高安全性和管理便利性。
- **故障隔离**：通过分库分表减少单点故障风险，即使某个分片出现问题，也不至于影响整个系统。

**5) 维护与管理**

- **备份与恢复**：单个大型数据库的备份和恢复操作耗时长、风险高，分库分表可以将这些操作分解，提高效率和灵活性。
- **性能调优**：分库分表后，可以针对不同业务或数据特性进行更精细化的优化，提升整体性能。

**(2) 分库分表方案**

- 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。
- 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

**(3) 常用的分库分表中间件**

- sharding-jdbc（当当）、Mycat、TDDL（淘宝）、Oceanus(58同城数据库中间件)、vitess（谷歌开发的数据库中间件）、Atlas(Qihoo 360)

**(4) 分库分表可能遇到的问题**

- 事务问题：需要用分布式事务
- 跨节点Join的问题：解决这一问题可以分两次查询实现
- 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。
- 数据迁移，容量规划，扩容等问题
- ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID
- 跨分片的排序分页问题（后台加大pagesize处理？）

### 1.1.3 加索引

加索引可以提升查询效率，但是需要知道是否有必要添加索引？如何添加索引？添加何种索引？以下给出一个示例。

**(1) 分析查询模式**

使用`EXPLAIN`分析查询。在决定为哪个字段添加索引之前，使用`EXPLAIN`分析慢查询，找出查询中的瓶颈。例如：

```sql
EXPLAIN SELECT * FROM your_table WHERE column_name = 'some_value';
```

**(2) 选择合适的索引类型**

- **主键和唯一索引**：自然适合于表的主键或唯一字段。

- **普通索引**：适用于经常出现在`WHERE`子句中的列。

- **组合索引**：如果查询涉及多个列，可以创建组合索引，注意索引列的顺序很重要，通常将选择性最高的列放在前面。
- **全文索引**：如果查询涉及文本搜索，可以考虑使用全文索引，但需注意全文索引占用空间较大。

**(3) 考虑索引维护成本**

- 在大量数据更新的列上添加索引可能增加写操作的开销，权衡读写性能。

**(4) 定期评估索引有效性**

- 定期检查和优化索引，移除不再使用的或低效的索引。

**(5) 添加索引示例**

- **添加普通索引**：

```sql
CREATE INDEX idx_column_name ON your_table(column_name);
```

- **添加组合索引**：

```sql
CREATE INDEX idx_column_name_another_column ON your_table(column_name, another_column);
```

- **添加全文索引**（假设数据库支持，如MySQL的InnoDB引擎）：

```sql
CREATE FULLTEXT INDEX ft_index ON your_table(text_column);
```

- **查看索引**：

```sql
SHOW INDEXES FROM your_table;
```

- **删除索引**（如果评估后发现某个索引不再需要）：

```sql
DROP INDEX idx_column_name ON your_table;
```

在执行任何索引操作前，建议在测试环境中先行测试，监控性能变化，确保新索引确实能提升查询效率且不会对写入性能产生不可接受的影响。此外，千万级数据量的数据库添加索引可能会消耗较长时间，最好在维护窗口进行操作。

## 1.2 其他常用策略

**(1) 避免全表扫描**

对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

**(2) 避免判断null值**

应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
`select id from t where num is null`
可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
`select id from t where num=0`

**(3) 避免使用or逻辑**

应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
`select id from t where num=10 or num=20`
可以这样查询：
`select id from t where num=10
union all
select id from t where num=20`

**(4) 注意模糊查询**

下面的查询也将导致全表扫描：
`select id from t where name like '%abc%'`
模糊查询如果是必要条件时，可以使用

`select id from t where name like 'abc%'`

来实现模糊查询，此时索引将被使用。如果头匹配是必要逻辑，建议使用全文搜索引擎（Elastic search、Lucene、Solr等）。

**(5) 避免查询条件中字段计算**

应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
`select id from t where num/2=100`
应改为:
`select id from t where num=100*2`

**(6) 避免查询条件中对字段进行函数操作**

应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
`select id from t where substring(name,1,3)='abc'--name以abc开头的id`
应改为:
`select id from t where name like 'abc%'`

**(7) 组合索引使用**

在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。(**最左匹配原则**)

**(8) exists**
很多时候用 exists 代替 in 是一个好的选择：
`select num from a where num in(select num from b)`
用下面的语句替换：
`select num from a where exists(select 1 from b where num=a.num)`

**(9) 小表驱动大表**

这个概念的核心思想是，在进行多表连接查询时，应该让数据量较小的表（小表）作为驱动表，去匹配数据量较大的表（大表），从而尽可能地减少循环匹配的次数，优化查询性能。

假设我们有两个表，一个是订单详情表（订单数量巨大，几百万条记录），另一个是商品表（商品种类相对较少，只有几千条记录）。当我们需要查询某个商品的所有订单时，应该这样写SQL：

```sql
SELECT o.*
FROM orders AS o
JOIN products AS p ON o.product_id = p.id
WHERE p.category = 'Electronics';
```

在这个例子中，通过在`JOIN`子句中明确指定`products`（小表）作为驱动表，并在`WHERE`子句中对小表进行过滤，可以显著减少需要遍历和比较的行数，从而提高查询效率。

**(10) 索引也可能失效**

**索引要在具有比较好的区分度的字段上建立，否则索引有可能会失效**。SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。

**(11) 表格字段类型选择**
**尽量使用数字型字段**，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为**引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了**。
尽可能的使用 varchar 代替 char ，因为首先可变长度字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

**(12) 索引无关优化**

- 不使用*、尽量不使用union，union all等关键字、尽量不使用or关键字、尽量使用等值判断。

- 表连接建议不超过5个。如果超过5个，则考虑表格的设计。（互联网应用中）

- 大数据量级的表格做分页查询时，如果页码数量过大，则使用子查询配合完成分页逻辑。
  `Select * from table limit 1000000, 10
  Select * from table where id in (select pk from table limit 100000, 10)`